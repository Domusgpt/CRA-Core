# CRA Agent MD Generation

## The Concept

When an agent connects to CRA via MCP, CRA generates a **custom markdown file** that:

1. Explains CRA tenets in language the agent understands
2. Contains the exact wrapper outputs CRA expects
3. Is tailored to this specific agent's model and capabilities
4. Gets added to the agent's instruction files (claude.md, agents.md, etc.)

This makes the agent self-sufficient in building its wrapper.

```
┌─────────────────────────────────────────────────────────────────┐
│                   MD Generation Flow                             │
│                                                                  │
│  1. Agent connects to CRA MCP                                    │
│                    ↓                                             │
│  2. CRA runs discovery (questions)                               │
│                    ↓                                             │
│  3. CRA generates custom .md based on answers                    │
│                    ↓                                             │
│  4. Agent adds reference to its claude.md                        │
│                    ↓                                             │
│  5. Agent reads generated .md                                    │
│                    ↓                                             │
│  6. Agent builds wrapper following exact specs                   │
│                    ↓                                             │
│  7. Wrapper integrates with CRA TRACE                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## Generated File Structure

### Location
```
.cra/
├── CRA-INTEGRATION-{session-id}.md    # Generated by MCP
├── trace/                              # TRACE logs go here
│   └── {session-id}.json
└── config.json                         # Domain config
```

### Reference in claude.md
```markdown
# Project Instructions

[existing instructions...]

## CRA Integration

This project uses CRA for governance. See `.cra/CRA-INTEGRATION-{session-id}.md` for:
- How to report actions
- How to request context
- TRACE format requirements
- Session-specific configuration

**You MUST follow the CRA integration instructions for this session.**
```

---

## Generated MD Template

CRA generates something like this, customized per agent:

```markdown
# CRA Integration for {model_identity}
Session ID: {session_id}
Generated: {timestamp}
Domain: {domain_name}

## Your Governance Rules

You are a {model_identity} agent operating in {authorization_level} environment.

### MUST Follow (Hard Rules)
{tailored_hard_rules}

### SHOULD Follow (Soft Rules)
{tailored_soft_rules}

---

## TRACE Integration

Your session is traced. To integrate correctly:

### Action Reporting Format

When you take a significant action, output this block:

```json
{
  "cra_action": {
    "session_id": "{session_id}",
    "action": "<what you're doing>",
    "params": {<relevant parameters>},
    "previous_hash": "<last hash you received>"
  }
}
```

CRA will respond with:
```json
{
  "cra_response": {
    "decision": "approved|denied",
    "hash": "<new chain hash>",
    "trace_id": "<event id>"
  }
}
```

Use the returned `hash` as your `previous_hash` for the next action.

### Context Request Format

When you need information:

```json
{
  "cra_context_request": {
    "session_id": "{session_id}",
    "need": "<what information would help>",
    "hints": ["optional", "keywords"]
  }
}
```

### Feedback Format

After using context:

```json
{
  "cra_feedback": {
    "session_id": "{session_id}",
    "context_id": "<which context>",
    "helpful": true|false,
    "reason": "<why>"
  }
}
```

---

## Context Available To You

Based on your intent ("{intent}"), these context blocks are available:

{context_summary_table}

Request any by ID using the context request format above.

---

## Session Specifics

- **Session ID**: `{session_id}`
- **Genesis Hash**: `{genesis_hash}`
- **Your Authorization**: `{authorization_level}`
- **Context Window**: `{context_window}` tokens
- **Active Atlases**: {atlas_list}

---

## Hash Chain State

Current chain position:
- Sequence: {sequence}
- Current Hash: `{current_hash}`

Your next action should reference this hash.

---

## Checkpoints

{if authorization_level == "production"}
Production environment: You MUST checkpoint before destructive actions.
Checkpoint format:
```json
{
  "cra_checkpoint": {
    "session_id": "{session_id}",
    "about_to": "<description of destructive action>",
    "rollback_plan": "<how to undo>"
  }
}
```
{endif}

---

## End Session

When finished:

```json
{
  "cra_end_session": {
    "session_id": "{session_id}",
    "summary": "<what you accomplished>"
  }
}
```

---

**This file is your contract with CRA. Follow these formats exactly and your actions will be properly traced.**
```

---

## Why This Approach

### Self-Sufficient Integration
The agent doesn't need to understand CRA internals. It just needs to:
1. Read the generated .md
2. Follow the formats specified
3. Include the session ID and previous hash

### Model-Specific Instructions
Different models get different instructions:
- Claude gets Claude-style markdown
- GPT gets GPT-style instructions
- Smaller models get simpler formats

### Session-Specific Configuration
Each session generates its own .md with:
- Unique session ID
- Genesis hash to start the chain
- Specific governance rules for that context

### Version Control Friendly
The .md file can be:
- Committed to the repo (for shared governance)
- Gitignored (for ephemeral sessions)
- Audited later (what instructions was agent given?)

---

## MCP Tool: Generate Integration MD

```json
{
  "name": "cra_generate_integration_md",
  "description": "Generates a custom markdown file with CRA integration instructions for this agent. Creates the file and returns its path.",
  "inputSchema": {
    "type": "object",
    "required": ["intent"],
    "properties": {
      "intent": {
        "type": "string",
        "description": "What you're trying to accomplish"
      },
      "output_path": {
        "type": "string",
        "description": "Where to write the .md file (default: .cra/CRA-INTEGRATION-{session}.md)"
      },
      "discovery_answers": {
        "type": "object",
        "description": "Pre-filled answers to discovery questions"
      }
    }
  }
}
```

**Returns:**
```json
{
  "md_path": ".cra/CRA-INTEGRATION-abc123.md",
  "session_id": "abc123",
  "genesis_hash": "sha256:e3b0c44...",
  "add_to_claude_md": "## CRA Integration\n\nSee `.cra/CRA-INTEGRATION-abc123.md` for governance instructions.\n\n**Follow these instructions for all actions.**"
}
```

---

## Integration into claude.md

The agent (or user) adds this to their `claude.md`:

```markdown
## CRA Integration

This project uses CRA (Context Registry for Agents) for governance and audit.

**Integration File:** `.cra/CRA-INTEGRATION-{session-id}.md`

### What CRA Does
- Tracks all significant actions (tamper-evident audit trail)
- Provides domain-specific context on request
- Records your feedback to improve future context

### Your Responsibility
- Read the integration file at the start of each session
- Follow the action/context/feedback formats exactly
- Include session_id and previous_hash in all CRA outputs
- End your session when done

### The Core Principle
"If it wasn't emitted by the runtime, it didn't happen."

Your outputs prove what you did. Follow the format. Be traceable.
```

---

## Flow Example

### 1. User Starts Project

```bash
$ tree
.
├── CLAUDE.md
├── src/
└── package.json
```

### 2. User Enables CRA

User installs CRA MCP server:
```json
{
  "mcpServers": {
    "cra": {
      "command": "cra-mcp-server",
      "args": ["--domain", "my-project"]
    }
  }
}
```

### 3. Agent Initializes CRA

Agent's first action:
```
Agent: I'll use cra_generate_integration_md to set up governance.

cra_generate_integration_md(
  intent: "Help user build website with VIB3 background"
)
```

CRA generates `.cra/CRA-INTEGRATION-sess123.md`

### 4. Agent Updates CLAUDE.md

Agent adds the CRA block to CLAUDE.md:

```markdown
## CRA Integration

See `.cra/CRA-INTEGRATION-sess123.md` for governance.
All actions must be reported per that file.
```

### 5. Agent Reads Integration File

Agent reads `.cra/CRA-INTEGRATION-sess123.md` to learn:
- How to format action reports
- What the current hash is
- What context is available

### 6. Agent Works With Full Integration

Every significant action now includes proper CRA output:
```json
{
  "cra_action": {
    "session_id": "sess123",
    "action": "write_file",
    "params": {"path": "index.html"},
    "previous_hash": "sha256:abc..."
  }
}
```

### 7. Everything Traced

CRA logs everything to `.cra/trace/sess123.json`

---

## Benefits

1. **Self-Documenting**: The .md file IS the integration spec
2. **Agent-Readable**: Agents can read and follow markdown
3. **Auditable**: What instructions did agent receive? Read the .md
4. **Customizable**: Each domain can customize the template
5. **Version-Controllable**: Commit the .md for reproducibility
6. **Model-Agnostic**: Works with any agent that can read files

---

## Future: Template System

Domains could customize their integration templates:

```json
{
  "domain": "vib3-development",
  "integration_template": "templates/vib3-integration.md.hbs",
  "required_sections": ["action_reporting", "context_requests"],
  "custom_sections": ["vib3_specific_rules"]
}
```

This lets each domain control exactly what instructions agents receive.

---

## Future: Skill Directory Package

For easy distribution, CRA could ship as a complete skill directory:

```
cra-skill/
├── package.json                    # npm package metadata
├── mcp-server/
│   ├── index.js                    # MCP server entry
│   └── tools/                      # Tool implementations
├── skills/
│   ├── claude/
│   │   ├── skill.json              # Claude skill manifest
│   │   └── instructions.md         # Claude-specific instructions
│   ├── openai/
│   │   ├── actions.yaml            # OpenAI Actions spec
│   │   └── instructions.md
│   └── generic/
│       └── instructions.md
├── templates/
│   ├── integration.md.hbs          # Handlebars template for generated .md
│   └── claude-md-block.md          # Block to add to claude.md
├── atlases/
│   └── (domain atlases bundled)
└── README.md                       # Quick start guide
```

### Installation

```bash
# npm
npx cra-skill init

# Or manual
git clone https://github.com/user/cra-skill
cp -r cra-skill/.cra ./
```

### What Gets Installed

1. **MCP server config** - Added to claude_code_config.json automatically
2. **Base atlases** - CRA bootstrap + domain atlases
3. **Templates** - For generating integration .md files
4. **CLAUDE.md block** - Ready to paste into existing CLAUDE.md

### One-Command Setup

```bash
npx cra-skill setup --domain my-project

# Creates:
# .cra/
# Updates claude_code_config.json
# Adds CRA block to CLAUDE.md
# Generates initial integration .md
```

This makes CRA adoption trivial - one command and you're governed.
