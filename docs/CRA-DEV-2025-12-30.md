# CRA Development Handoff
**Document ID:** CRA-DEV-2025-12-30
**Status:** Active Development
**Branch:** `claude/cra-rust-refactor-*`

---

## What is CRA?

**CRA (Context Registry for Agents)** is a governance and audit layer for AI agents. It provides three core protocols:

### 1. CARP (Context & Action Resolution Protocol)
**Purpose:** Determine what an agent CAN do and what context they SHOULD receive.

**How it works:**
- Agent sends a `CARPRequest` with a goal (e.g., "Add a shader background to my site")
- Resolver evaluates loaded atlases
- Policies determine which actions are allowed/denied
- Context blocks are matched to the goal by keywords
- Returns `CARPResolution` with allowed actions + relevant context

**Key insight:** CARP doesn't control the agent. It provides information and records what was provided.

### 2. TRACE (Telemetry & Replay Audit Contract for Execution)
**Purpose:** Cryptographic proof of what happened.

**How it works:**
- Every operation emits a `TRACEEvent`
- Events form a hash chain (each event's hash depends on the previous)
- Chain is tamper-evident - modifying any event breaks verification
- Provides audit trail: "If it wasn't emitted by the runtime, it didn't happen"

**Event types:**
- `session.started` / `session.ended`
- `carp.request.received` / `carp.resolution.completed`
- `policy.evaluated`
- `context.injected` ← Key: proves what guidance agent received
- `action.requested` / `action.approved` / `action.denied` / `action.executed`

### 3. Atlas (Versioned Context Packages)
**Purpose:** Bundle everything needed to govern agent behavior in a domain.

**Contains:**
- `context_blocks` - Markdown content injected based on goal keywords
- `actions` - What operations the agent can perform
- `policies` - Rules for allowing/denying actions
- `capabilities` - Grouped sets of actions
- `sources` - Links to repos, docs, demos

---

## Core Principle

> **"If it wasn't emitted by the runtime, it didn't happen."**

CRA inverts the authority model:
- Traditional: LLM claims what it did → trust the LLM
- CRA: Runtime records what happened → cryptographic proof

---

## Code Architecture

```
cra-core/src/
├── lib.rs              # Public exports, version constants
├── error.rs            # CRAError enum, Result type
│
├── carp/               # CARP Protocol
│   ├── mod.rs          # Re-exports
│   ├── resolver.rs     # Main entry point - Resolver struct
│   ├── request.rs      # CARPRequest
│   ├── resolution.rs   # CARPResolution, Decision enum
│   └── policy.rs       # PolicyEvaluator, PolicyResult
│
├── trace/              # TRACE Protocol
│   ├── mod.rs          # Re-exports, VERSION, GENESIS_HASH
│   ├── event.rs        # TRACEEvent, EventType, compute_hash()
│   ├── collector.rs    # TraceCollector, deferred mode
│   ├── chain.rs        # ChainVerifier, verification logic
│   ├── buffer.rs       # Lock-free ring buffer
│   └── processor.rs    # Background processing
│
├── atlas/              # Atlas System
│   ├── mod.rs          # Re-exports
│   ├── manifest.rs     # AtlasManifest, AtlasContextBlock, InjectMode
│   ├── loader.rs       # File loading
│   └── validator.rs    # Schema validation
│
├── context/            # Context Matching
│   ├── mod.rs          # Re-exports
│   ├── registry.rs     # ContextRegistry
│   └── matcher.rs      # ContextMatcher, keyword matching
│
├── storage/            # Storage Backends
│   └── mod.rs          # InMemoryStorage, FileStorage, NullStorage
│
└── timing/             # Timer System
    ├── mod.rs          # Re-exports
    ├── manager.rs      # TimerManager
    └── backends/       # Mock, Std backends
```

---

## Key Files to Understand

### For Hash/Chain Operations
**READ FIRST:** `cra-core/src/trace/event.rs`
- `TRACEEvent::compute_hash()` - THE canonical hash implementation
- `canonical_json()` - Deterministic JSON serialization (sorted keys)
- Never reimplement hash logic

### For Resolution Flow
**READ:** `cra-core/src/carp/resolver.rs`
- `Resolver::resolve()` - Main CARP resolution
- `Resolver::execute()` - Action execution recording
- How context blocks are matched and injected

### For Atlas Schema
**READ:** `cra-core/src/atlas/manifest.rs`
- `AtlasManifest` - Top-level structure
- `AtlasContextBlock` - Context with keywords, priority, inject_mode
- `InjectMode` - always, on_match, on_demand, risk_based

---

## Atlas System Design

### Why Atlases Exist
Atlases bundle domain-specific knowledge so agents can be governed without hardcoding rules into the runtime. An atlas for "VIB3+ development" contains everything an agent needs to use VIB3 correctly.

### Context Injection Modes
```rust
pub enum InjectMode {
    Always,      // Always inject when atlas active (essential facts)
    OnMatch,     // Inject when keywords match goal (default)
    OnDemand,    // Only if explicitly requested
    RiskBased,   // Based on action risk tier
}
```

### Keyword Matching
Context blocks have `keywords: Vec<String>`. The goal text is matched against these keywords. Matching blocks are injected into the resolution.

### Priority System
Higher priority blocks appear first in the response. Use for:
- 400+ : Essential facts (always inject)
- 300-399: Workflow guidance
- 200-299: Reference material
- 100-199: Debug/advanced info

### also_inject
Blocks can reference other blocks to inject together:
```json
{
  "context_id": "workflow-embed",
  "also_inject": ["essential-facts"]
}
```

---

## Current Atlases

### 1. cra-development.json
Self-governance atlas for CRA development. Prevents common mistakes like reimplementing hash computation.

### 2. vib3-webpage-development.json (v6.0.0)
Atlas for VIB3+ shader visualization engine. Contains:
- 10 context blocks
- System overview (3 working systems, polychora placeholder)
- Geometry system (8 base × 3 core = 24)
- JavaScript API (window.switchSystem, selectGeometry, updateParameter)
- Audio reactivity (3 frequency bands)
- Mouse/touch interactivity
- Parameters reference
- State/debugging info

---

## What's Been Done

### Schema Improvements
- Added `InjectMode` enum
- Added `AtlasSources` struct (repositories, documentation, demo URLs)
- Added `also_inject` field for context dependencies
- Added `inject_mode` field to context blocks and packs

### VIB3 Atlas
- Read actual source code from GitHub repos
- Verified API functions, parameters, keyboard shortcuts
- Created 10 context blocks covering full system
- Corrected errors (polychora is placeholder, all systems share 24 geometries)

### Documentation
- `docs/CRA_TESTING_PLAN.md` - What proper testing looks like
- `docs/CRA_QUICK_OVERVIEW.md` - Quick system explanation
- `docs/CRA_LANDSCAPE_ANALYSIS.md` - How CRA compares to Claude Skills, OpenAI Agents
- `docs/VIB3_COMPLETE_USAGE_GUIDE.md` - Full VIB3 reference
- `docs/VIB3_VERIFICATION_PLAN.md` / `VIB3_VERIFICATION_RESULTS.md` - Verification process

---

## What's NOT Done (Testing Gaps)

### 1. Real Agentic Tests
We have NOT tested with actual agents. Current tests:
- ✅ Unit tests (pass)
- ✅ Integration tests (pass)
- ✅ Conformance tests (need schema fixes)
- ❌ Real agent comparison (Agent A without CRA vs Agent B with CRA)

### 2. Schema Migration
Some test files still need `inject_mode` and `also_inject` fields added:
- `cra-core/tests/conformance.rs`
- Some test helpers with AtlasContextBlock structs

### 3. Simulated Tests Removal
Files with fake "agent thinking" simulations should be removed or rewritten:
- `cra-core/tests/vib3_detailed_execution.rs` - Contains simulated behavior

---

## How to Run Tests

```bash
# All unit tests
cargo test --lib

# Integration tests
cargo test --tests

# Specific test file
cargo test --test vib3_context_demo -- --nocapture

# Self-governance tests
cargo test --test self_governance -- --nocapture

# Conformance tests (may fail until schema fixed)
cargo test --test conformance
```

---

## Next Steps for Development

### Immediate
1. Fix remaining schema compilation errors in test files
2. Remove or rewrite simulation tests
3. Run full test suite and verify all pass

### Testing Priority
1. Design real agent comparison test
2. Set up two agents: one with CRA context, one without
3. Give same task, record terminal sessions
4. Compare behavior and outcomes
5. Document findings

### Future
1. Implement `InjectMode::Always` handling in resolver
2. Add more atlases for different domains
3. Build tooling for atlas creation/validation
4. Consider WASM build for browser use

---

## Repository Structure

```
CRA-Core/
├── cra-core/           # Main Rust library
│   ├── src/            # Source code
│   ├── tests/          # Integration tests
│   └── Cargo.toml
├── cra-wasm/           # WASM bindings (WIP)
├── atlases/            # Atlas JSON files
│   ├── cra-development.json
│   ├── vib3-webpage-development.json
│   └── ...
├── docs/               # Documentation
├── specs/              # Protocol specifications
│   └── conformance/    # Golden traces for testing
└── CLAUDE.md           # Development instructions
```

---

## Key Contacts / Resources

- **Repository:** Current branch `claude/cra-rust-refactor-*`
- **VIB3 Demo:** https://domusgpt.github.io/vib3-plus-engine/
- **VIB3 Source:** https://github.com/Domusgpt/vib3-plus-engine

---

## Critical Rules

1. **Never reimplement hash computation** - Use `TRACEEvent::compute_hash()`
2. **Use canonical_json()** - Not `serde_json::to_string()` for payload hashing
3. **Read before modifying** - Always read source files before changes
4. **Test with real atlases** - Don't create fake test atlases
5. **No simulations** - Test actual system behavior, not made-up scenarios
