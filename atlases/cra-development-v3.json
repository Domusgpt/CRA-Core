{
  "atlas_version": "1.0",
  "atlas_id": "dev.cra.self-governance",
  "version": "3.0.0",
  "name": "CRA Self-Governance Atlas v3",
  "description": "Comprehensive governance for AI agents developing CRA. Injects structured, complete context with documentation references and current-vs-ideal comparisons.",
  "authors": ["CRA Development Team"],
  "license": "MIT",
  "domains": ["development", "cra-core", "rust"],

  "capabilities": [
    {
      "capability_id": "cra.develop",
      "name": "CRA Development",
      "actions": ["code.read", "code.modify", "test.run", "docs.read"]
    }
  ],

  "context_blocks": [
    {
      "context_id": "system-overview",
      "name": "CRA Complete System Overview",
      "priority": 300,
      "content_type": "text/markdown",
      "keywords": ["cra", "overview", "architecture", "system", "what", "how", "understand", "explain", "help"],
      "inject_when": [],
      "risk_tiers": [],
      "content": "# CRA (Context Registry for Agents) - Complete System Overview\n\n## What CRA Is\n\nCRA is a **governance layer for AI agents** providing three core protocols:\n\n| Protocol | Purpose | Key Files |\n|----------|---------|----------|\n| **CARP** | Context & Action Resolution Protocol - determines what actions are allowed | `cra-core/src/carp/` |\n| **TRACE** | Telemetry & Replay Audit Contract - cryptographic proof of what happened | `cra-core/src/trace/` |\n| **Atlas** | Versioned packages defining agent capabilities and policies | `cra-core/src/atlas/` |\n\n## Core Principle\n\n> **\"If it wasn't emitted by the runtime, it didn't happen.\"**\n\nEvery action, decision, and context injection is recorded in a cryptographically-linked hash chain.\n\n## Documentation Locations\n\n| Document | Path | Contents |\n|----------|------|----------|\n| **Development Guide** | `/CLAUDE.md` | Quick reference for developers |\n| **Testing Standards** | `/docs/TESTING_STANDARDS.md` | Test patterns and requirements |\n| **Self-Governance Docs** | `/docs/SELF_GOVERNANCE.md` | How CRA governs itself |\n| **Protocol Specs** | `/specs/` | Formal protocol specifications |\n| **Golden Traces** | `/specs/conformance/golden/` | Reference implementations |\n\n## Current Architecture vs Ideal\n\n### Current State\n```\nResolver → PolicyEvaluator → ContextRegistry → TraceCollector\n    ↓           ↓                  ↓               ↓\n  Wired     Evaluates         Keyword-based    Hash chain\n  together  allow/deny         matching        with events\n```\n\n### Ideal State (gaps to fill)\n1. **Context Packs**: File-based context (`context_packs`) not yet implemented - only inline `context_blocks` work\n2. **Structured Output**: Context blocks should return structured JSON, not just markdown\n3. **Semantic Matching**: Currently keyword-based; should be embedding/semantic\n4. **Priority Ordering**: Context blocks should be strictly sorted by priority before injection\n5. **Token Budgeting**: Should respect token limits and prioritize within budget\n\n## Data Flow\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        AGENT REQUEST                            │\n│  Goal: \"I need to modify hash computation\"                      │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                         RESOLVER                                │\n│  1. Validate request                                            │\n│  2. Emit carp.request.received                                  │\n│  3. Evaluate policies → allow/deny each action                  │\n│  4. Query ContextRegistry → match keywords in goal              │\n│  5. Inject matching context_blocks                              │\n│  6. Emit context.injected for each block                        │\n│  7. Return CARPResolution                                       │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                      CARP RESOLUTION                            │\n│  {                                                              │\n│    \"decision\": \"allow\",                                         │\n│    \"allowed_actions\": [...],                                    │\n│    \"context_blocks\": [                                          │\n│      { \"block_id\": \"hash-rules\", \"content\": \"...\" }            │\n│    ]                                                            │\n│  }                                                              │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Quick Start Commands\n\n```bash\n# Run all tests (117+ should pass)\ncargo test --lib\n\n# Run conformance tests\ncargo test --test conformance\n\n# Run self-governance demo\ncargo test --test context_demo -- --nocapture\n\n# Run benchmarks\ncargo bench --bench resolver_bench\n```\n\n## Key Invariants (NEVER violate)\n\n1. **Hash chain integrity**: Events are cryptographically linked\n2. **Append-only trace**: Never modify or delete events\n3. **Single hash implementation**: Only `TRACEEvent::compute_hash()` computes hashes\n4. **Canonical JSON**: Use `canonical_json()` for deterministic serialization"
    },
    {
      "context_id": "hash-and-trace-complete",
      "name": "Complete Hash & Trace Guide",
      "priority": 250,
      "content_type": "text/markdown",
      "keywords": ["hash", "trace", "chain", "compute_hash", "sha256", "event", "collector", "verify", "canonical", "event_hash", "previous"],
      "inject_when": ["trace.edit_event", "trace.edit_collector", "trace.edit_chain"],
      "risk_tiers": ["high", "critical"],
      "content": "# Complete Hash & Trace Implementation Guide\n\n## Files You MUST Read First\n\n| File | What It Contains | Read Before |\n|------|-----------------|-------------|\n| `cra-core/src/trace/event.rs` | `TRACEEvent::compute_hash()` - THE canonical hash implementation | ANY hash work |\n| `cra-core/src/trace/collector.rs` | `TraceCollector` - event emission and deferred mode | Modifying event flow |\n| `cra-core/src/trace/chain.rs` | `ChainVerifier` - validates hash chain integrity | Verification logic |\n| `cra-core/src/trace/buffer.rs` | Lock-free ring buffer for high-throughput | Performance work |\n\n## The Hash Computation (NEVER reimplement)\n\n```rust\n// Location: cra-core/src/trace/event.rs\nimpl TRACEEvent {\n    pub fn compute_hash(&self) -> String {\n        let mut hasher = Sha256::new();\n        \n        // Order matters! All 11 components:\n        hasher.update(TRACE_VERSION);           // \"1.0\"\n        hasher.update(&self.event_id);          // UUID\n        hasher.update(&self.trace_id);          // UUID  \n        hasher.update(&self.span_id);           // UUID\n        hasher.update(&self.parent_span_id);    // Option<UUID>\n        hasher.update(&self.session_id);        // UUID\n        hasher.update(self.sequence.to_le_bytes()); // u64 little-endian\n        hasher.update(self.timestamp.to_rfc3339()); // ISO 8601\n        hasher.update(self.event_type.as_str());    // e.g., \"session.started\"\n        hasher.update(canonical_json(&self.payload)); // SORTED KEYS!\n        hasher.update(&self.previous_event_hash);     // Links to prior event\n        \n        hex::encode(hasher.finalize())\n    }\n}\n```\n\n## Current vs Ideal Implementation\n\n### Current State ✓\n- Hash computation centralized in `compute_hash()`\n- `canonical_json()` ensures deterministic key ordering\n- Chain verification works via `ChainVerifier`\n- Deferred mode stores placeholder, calls `compute_hash()` on flush\n\n### Problems / Technical Debt\n1. **No streaming hash**: Large payloads load fully into memory\n2. **No parallel verification**: Chain verified sequentially\n3. **Placeholder is literal string**: `\"deferred\"` as hash value is hacky\n\n### Ideal Implementation\n```rust\n// Streaming hash for large payloads\npub fn compute_hash_streaming<R: Read>(&self, payload_reader: R) -> String;\n\n// Parallel chain verification\npub fn verify_chain_parallel(&self, num_threads: usize) -> VerificationResult;\n\n// Proper deferred state\nenum HashState {\n    Computed(String),\n    Deferred { compute_on_access: bool },\n}\n```\n\n## Common Mistakes & Fixes\n\n| Mistake | Why It's Wrong | Correct Approach |\n|---------|---------------|------------------|\n| `serde_json::to_string(&payload)` | Non-deterministic key order | `canonical_json(&payload)` |\n| Reimplementing hash logic | Creates divergence, breaks chain | Call `event.compute_hash()` |\n| Forgetting `previous_event_hash` | Breaks chain linkage | Always include in hash |\n| Wrong byte order for sequence | Hash mismatch | Use `to_le_bytes()` |\n\n## Test Commands\n\n```bash\n# Hash-specific tests\ncargo test hash\ncargo test compute_hash\ncargo test chain\n\n# Deferred mode tests\ncargo test deferred\ncargo test flush\n\n# Full trace tests\ncargo test trace::\n```\n\n## Verification\n\n```rust\n// Always verify chain after modifications\nlet verification = resolver.verify_chain(&session_id)?;\nassert!(verification.is_valid, \"Chain broken: {:?}\", verification.error_type);\n```"
    },
    {
      "context_id": "context-registry-complete",
      "name": "Complete Context Registry Guide",
      "priority": 240,
      "content_type": "text/markdown",
      "keywords": ["context", "registry", "inject", "matcher", "matching", "block", "keyword", "query", "conditions"],
      "inject_when": ["context.edit_registry", "context.edit_matcher"],
      "risk_tiers": [],
      "content": "# Complete Context Registry Implementation Guide\n\n## Files You MUST Read First\n\n| File | What It Contains |\n|------|------------------|\n| `cra-core/src/context/registry.rs` | `ContextRegistry` - stores and queries context |\n| `cra-core/src/context/matcher.rs` | `ContextMatcher` - evaluates injection conditions |\n| `cra-core/src/carp/resolver.rs` | Where context injection is wired (lines ~200-250) |\n| `cra-core/src/atlas/manifest.rs` | `AtlasContextBlock` struct definition |\n\n## Architecture\n\n```\n┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐\n│  Atlas          │     │ ContextRegistry  │     │ ContextMatcher  │\n│  .context_blocks│────▶│ .contexts: Vec   │────▶│ .evaluate()     │\n└─────────────────┘     └──────────────────┘     └─────────────────┘\n        ↓                       ↓                        ↓\n   load_atlas()            query(goal)             score conditions\n        ↓                       ↓                        ↓\n   Converts to              Returns matching       Returns MatchResult\n   LoadedContext            LoadedContext[]        { matched, score }\n```\n\n## Current Implementation\n\n```rust\n// In resolver.rs load_atlas():\nfor block in &atlas.context_blocks {\n    let loaded = LoadedContext {\n        pack_id: block.context_id.clone(),\n        source: ContextSource::Atlas(atlas_id.clone()),\n        content: block.content.clone(),\n        keywords: block.keywords.clone(),\n        // ...\n    };\n    self.context_registry.add_context(loaded);\n}\n\n// In resolver.rs resolve():\nlet matching = self.context_registry.query(&request.goal, None);\nfor ctx in matching {\n    if self.context_matcher.evaluate(...).matched {\n        context_blocks.push(ctx.to_context_block());\n        self.trace_collector.emit(EventType::ContextInjected, ...);\n    }\n}\n```\n\n## Current vs Ideal\n\n### Current State\n| Feature | Status | Notes |\n|---------|--------|-------|\n| Keyword matching | ✓ Working | Simple substring search |\n| Priority ordering | ✓ Partial | Sorted but not strictly enforced |\n| Risk tier filtering | ✓ Working | Matches request risk |\n| TRACE events | ✓ Working | Emits context.injected |\n| File-based packs | ✗ Missing | `context_packs` not implemented |\n| Semantic matching | ✗ Missing | No embeddings |\n| Token budgeting | ✗ Missing | No limit enforcement |\n\n### Ideal Implementation\n\n```rust\n// 1. Semantic matching with embeddings\npub struct ContextRegistry {\n    contexts: Vec<LoadedContext>,\n    embeddings: HashMap<String, Vec<f32>>,  // context_id -> embedding\n    embedding_model: Box<dyn EmbeddingModel>,\n}\n\nimpl ContextRegistry {\n    pub fn query_semantic(&self, goal: &str, threshold: f32) -> Vec<&LoadedContext> {\n        let goal_embedding = self.embedding_model.embed(goal);\n        self.contexts\n            .iter()\n            .filter(|ctx| cosine_similarity(&goal_embedding, &self.embeddings[&ctx.pack_id]) > threshold)\n            .collect()\n    }\n}\n\n// 2. Token budgeting\npub struct InjectionBudget {\n    max_tokens: usize,\n    reserved_for_response: usize,\n}\n\nimpl ContextRegistry {\n    pub fn query_with_budget(&self, goal: &str, budget: InjectionBudget) -> Vec<&LoadedContext> {\n        let mut selected = vec![];\n        let mut used_tokens = 0;\n        \n        for ctx in self.query(goal, None).iter().sorted_by_key(|c| -c.priority) {\n            if used_tokens + ctx.token_count <= budget.max_tokens {\n                selected.push(ctx);\n                used_tokens += ctx.token_count;\n            }\n        }\n        selected\n    }\n}\n\n// 3. Structured output\npub struct StructuredContext {\n    pub summary: String,\n    pub key_points: Vec<String>,\n    pub code_examples: Vec<CodeExample>,\n    pub documentation_refs: Vec<DocRef>,\n    pub warnings: Vec<Warning>,\n}\n```\n\n## Test Commands\n\n```bash\ncargo test context::\ncargo test matcher\ncargo test registry\ncargo test --test self_governance\ncargo test --test context_demo -- --nocapture\n```"
    },
    {
      "context_id": "resolver-and-carp-complete",
      "name": "Complete Resolver & CARP Guide",
      "priority": 230,
      "content_type": "text/markdown",
      "keywords": ["resolver", "carp", "resolve", "request", "resolution", "policy", "action", "allow", "deny"],
      "inject_when": ["carp.edit_resolver", "carp.edit_policy"],
      "risk_tiers": [],
      "content": "# Complete Resolver & CARP Implementation Guide\n\n## Files You MUST Read First\n\n| File | What It Contains |\n|------|------------------|\n| `cra-core/src/carp/resolver.rs` | Main entry point - wires everything together |\n| `cra-core/src/carp/request.rs` | `CARPRequest` structure |\n| `cra-core/src/carp/resolution.rs` | `CARPResolution`, `ContextBlock` |\n| `cra-core/src/carp/policy.rs` | `PolicyEvaluator` - allow/deny logic |\n\n## The Resolver's Role\n\nThe Resolver is the **central orchestrator** of CRA. It:\n\n1. Manages sessions (create, track, end)\n2. Loads and stores Atlas manifests\n3. Evaluates policies for each action\n4. Queries ContextRegistry for relevant context\n5. Emits TRACE events for everything\n6. Returns CARPResolutions\n\n## Complete resolve() Flow\n\n```rust\npub fn resolve(&mut self, request: &CARPRequest) -> Result<CARPResolution> {\n    // 1. Validate\n    self.validate_request(request)?;\n    \n    // 2. Get session\n    let session = self.sessions.get_mut(&request.session_id)\n        .ok_or(CRAError::SessionNotFound)?;\n    \n    // 3. Emit request received\n    self.trace_collector.emit(EventType::CARPRequestReceived, json!({\n        \"request_id\": request.request_id,\n        \"operation\": \"resolve\",\n        \"goal\": request.goal\n    }))?;\n    \n    // 4. Evaluate policies for each action in loaded atlases\n    let mut allowed_actions = vec![];\n    let mut denied_actions = vec![];\n    \n    for atlas in &self.atlases {\n        for action in &atlas.actions {\n            match self.policy_evaluator.evaluate(&action.action_id, &atlas.policies) {\n                PolicyResult::Allow => {\n                    self.trace_collector.emit(EventType::PolicyEvaluated, json!({\n                        \"action_id\": action.action_id,\n                        \"result\": \"allow\"\n                    }))?;\n                    allowed_actions.push(action.to_allowed());\n                }\n                PolicyResult::Deny { policy_id, reason } => {\n                    self.trace_collector.emit(EventType::PolicyEvaluated, json!({\n                        \"action_id\": action.action_id,\n                        \"result\": \"deny\",\n                        \"policy_id\": policy_id\n                    }))?;\n                    denied_actions.push(DeniedAction { action_id, policy_id, reason });\n                }\n            }\n        }\n    }\n    \n    // 5. Query and inject context (THE KEY PART)\n    let mut context_blocks = vec![];\n    let matching_contexts = self.context_registry.query(&request.goal, None);\n    \n    for ctx in matching_contexts {\n        let match_result = self.context_matcher.evaluate(\n            ctx.conditions.as_ref(),\n            &request.goal,\n            request.risk_tier,\n            &request.context_hints,\n            ctx.priority,\n        );\n        \n        if match_result.matched {\n            let block = ctx.to_context_block();\n            self.trace_collector.emit(EventType::ContextInjected, json!({\n                \"context_id\": ctx.pack_id,\n                \"source_atlas\": ctx.source,\n                \"priority\": ctx.priority,\n                \"match_score\": match_result.score.total()\n            }))?;\n            context_blocks.push(block);\n        }\n    }\n    \n    // 6. Build resolution\n    let decision = match (allowed_actions.is_empty(), denied_actions.is_empty()) {\n        (false, true) => Decision::Allow,\n        (true, false) => Decision::Deny,\n        (false, false) => Decision::Partial,\n        (true, true) => Decision::Allow, // No actions defined\n    };\n    \n    self.trace_collector.emit(EventType::CARPResolutionCompleted, json!({\n        \"decision_type\": decision,\n        \"allowed_count\": allowed_actions.len(),\n        \"denied_count\": denied_actions.len(),\n        \"context_block_count\": context_blocks.len()\n    }))?;\n    \n    Ok(CARPResolution {\n        decision,\n        allowed_actions,\n        denied_actions,\n        context_blocks,\n        // ...\n    })\n}\n```\n\n## Current vs Ideal\n\n### Current Gaps\n1. **No request queuing**: Requests processed synchronously\n2. **No caching**: Same goal re-evaluates everything\n3. **No partial resolution**: Can't return subset of actions\n4. **Single-threaded**: No concurrent resolution\n\n### Ideal Additions\n```rust\n// Cached resolution for repeated goals\npub struct ResolutionCache {\n    cache: LruCache<GoalHash, CARPResolution>,\n    ttl: Duration,\n}\n\n// Async resolution\npub async fn resolve_async(&self, request: &CARPRequest) -> Result<CARPResolution>;\n\n// Streaming context for large responses\npub fn resolve_streaming(&self, request: &CARPRequest) -> impl Stream<Item = ContextChunk>;\n```"
    },
    {
      "context_id": "testing-complete",
      "name": "Complete Testing Guide",
      "priority": 200,
      "content_type": "text/markdown",
      "keywords": ["test", "testing", "cargo", "conformance", "bench", "coverage", "failing", "pass"],
      "inject_when": [],
      "risk_tiers": [],
      "content": "# Complete CRA Testing Guide\n\n## Test File Locations\n\n| Path | Test Type | Count |\n|------|-----------|-------|\n| `cra-core/src/**/*.rs` | Unit tests (inline) | 117 |\n| `cra-core/tests/conformance.rs` | Protocol conformance | 12 |\n| `cra-core/tests/self_governance.rs` | Self-governance integration | 7 |\n| `cra-core/tests/context_demo.rs` | Context injection demos | 4 |\n| `specs/conformance/golden/` | Golden trace files | N/A |\n\n## Commands\n\n```bash\n# ALL tests (must pass before any commit)\ncargo test\n\n# Unit tests only\ncargo test --lib\n\n# Specific module\ncargo test trace::\ncargo test carp::\ncargo test context::\ncargo test atlas::\n\n# Specific test\ncargo test test_hash_context_injection\n\n# With output\ncargo test -- --nocapture\n\n# Conformance\ncargo test --test conformance\n\n# Benchmarks\ncargo bench --bench resolver_bench\n```\n\n## Current Test Coverage\n\n| Module | Tests | Coverage Area |\n|--------|-------|---------------|\n| `trace::event` | 12 | Hash computation, serialization |\n| `trace::collector` | 8 | Event emission, deferred mode |\n| `trace::chain` | 7 | Chain verification |\n| `carp::resolver` | 10 | Resolution flow |\n| `carp::policy` | 6 | Policy evaluation |\n| `context::registry` | 5 | Context storage, querying |\n| `context::matcher` | 3 | Condition matching |\n\n## Test Patterns\n\n### Basic Unit Test\n```rust\n#[test]\nfn test_feature_works() {\n    let mut resolver = Resolver::new();\n    let atlas = create_test_atlas();\n    resolver.load_atlas(atlas).unwrap();\n    \n    let session_id = resolver.create_session(\"agent\", \"goal\").unwrap();\n    let request = CARPRequest::new(session_id, \"agent\".into(), \"goal\".into());\n    let resolution = resolver.resolve(&request).unwrap();\n    \n    // Always verify chain integrity\n    let verification = resolver.verify_chain(&session_id).unwrap();\n    assert!(verification.is_valid);\n}\n```\n\n### Conformance Test Pattern\n```rust\n#[test]\nfn conformance_feature_behaves_correctly() {\n    // Load golden data\n    let expected = load_golden_trace();\n    \n    // Execute\n    let actual = run_scenario();\n    \n    // Compare (allow dynamic fields)\n    assert_events_match(expected, actual, &[\"event_id\", \"timestamp\"]);\n}\n```\n\n## Current vs Ideal Testing\n\n### Gaps\n1. **No property-based tests**: Should use proptest for edge cases\n2. **No fuzzing**: Hash computation should be fuzz-tested\n3. **No integration with real LLMs**: Only synthetic tests\n4. **No performance regression tests**: Benchmarks exist but no CI gates\n\n### Ideal Additions\n```rust\n// Property-based testing\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn hash_deterministic(event: TRACEEvent) {\n        let hash1 = event.compute_hash();\n        let hash2 = event.compute_hash();\n        assert_eq!(hash1, hash2);\n    }\n}\n\n// Fuzzing\n#[fuzz]\nfn fuzz_canonical_json(data: &[u8]) {\n    if let Ok(value) = serde_json::from_slice(data) {\n        let json1 = canonical_json(&value);\n        let json2 = canonical_json(&value);\n        assert_eq!(json1, json2);\n    }\n}\n```"
    },
    {
      "context_id": "project-structure-complete",
      "name": "Complete Project Structure",
      "priority": 180,
      "content_type": "text/markdown",
      "keywords": ["file", "directory", "structure", "where", "find", "location", "path", "module"],
      "inject_when": [],
      "risk_tiers": [],
      "content": "# Complete CRA Project Structure\n\n## Directory Tree\n\n```\nCRA-Core/\n├── CLAUDE.md                    # Developer quick reference (READ THIS)\n├── Cargo.toml                   # Workspace manifest\n├── README.md                    # Project overview\n│\n├── atlases/                     # Atlas definitions\n│   └── cra-development.json     # Self-governance atlas (v2.0.0)\n│\n├── cra-core/                    # Core Rust library\n│   ├── Cargo.toml\n│   ├── src/\n│   │   ├── lib.rs               # Public exports\n│   │   ├── error.rs             # CRAError, Result type\n│   │   │\n│   │   ├── carp/                # CARP Protocol\n│   │   │   ├── mod.rs           # Module exports\n│   │   │   ├── resolver.rs      # ★ MAIN ENTRY POINT\n│   │   │   ├── request.rs       # CARPRequest\n│   │   │   ├── resolution.rs    # CARPResolution, ContextBlock\n│   │   │   └── policy.rs        # PolicyEvaluator\n│   │   │\n│   │   ├── trace/               # TRACE Protocol\n│   │   │   ├── mod.rs           # Module exports\n│   │   │   ├── event.rs         # ★ TRACEEvent, compute_hash()\n│   │   │   ├── collector.rs     # TraceCollector, deferred mode\n│   │   │   ├── chain.rs         # ChainVerifier\n│   │   │   └── buffer.rs        # Lock-free ring buffer\n│   │   │\n│   │   ├── atlas/               # Atlas Handling\n│   │   │   ├── mod.rs           # Module exports\n│   │   │   ├── manifest.rs      # AtlasManifest, AtlasContextBlock\n│   │   │   └── loader.rs        # AtlasLoader\n│   │   │\n│   │   ├── context/             # ★ Context Registry (NEW)\n│   │   │   ├── mod.rs           # Module exports\n│   │   │   ├── registry.rs      # ContextRegistry\n│   │   │   └── matcher.rs       # ContextMatcher\n│   │   │\n│   │   ├── timing/              # Performance utilities\n│   │   │   └── mod.rs           # Timers, rate limiting\n│   │   │\n│   │   └── storage/             # Storage backends\n│   │       └── mod.rs           # Storage traits\n│   │\n│   ├── tests/                   # Integration tests\n│   │   ├── conformance.rs       # Protocol conformance (12 tests)\n│   │   ├── self_governance.rs   # Self-governance (7 tests)\n│   │   └── context_demo.rs      # Context demos (4 tests)\n│   │\n│   └── benches/                 # Benchmarks\n│       └── resolver_bench.rs    # Performance benchmarks\n│\n├── cra-python/                  # Python bindings (PyO3)\n│   ├── Cargo.toml\n│   └── src/lib.rs\n│\n├── cra-node/                    # Node.js bindings (NAPI)\n│   ├── Cargo.toml\n│   └── src/lib.rs\n│\n├── cra-wasm/                    # WebAssembly bindings\n│   ├── Cargo.toml\n│   └── src/lib.rs\n│\n├── docs/                        # Documentation\n│   ├── TESTING_STANDARDS.md     # Test patterns and requirements\n│   └── SELF_GOVERNANCE.md       # Self-governance pattern\n│\n├── scripts/                     # Development scripts\n│   └── analyze_tests.sh         # Test analysis tool\n│\n└── specs/                       # Protocol specifications\n    └── conformance/\n        └── golden/              # Golden trace files\n            └── simple-resolve/\n                ├── atlas.json\n                ├── expected-resolution.json\n                └── expected-trace.jsonl\n```\n\n## Key Files by Task\n\n| If You're Working On | Read These Files First |\n|---------------------|------------------------|\n| Hash computation | `trace/event.rs`, `trace/chain.rs` |\n| Event emission | `trace/collector.rs`, `trace/event.rs` |\n| Context injection | `context/registry.rs`, `context/matcher.rs`, `carp/resolver.rs` |\n| Policy evaluation | `carp/policy.rs`, `carp/resolver.rs` |\n| Atlas loading | `atlas/manifest.rs`, `atlas/loader.rs` |\n| Adding new tests | `tests/conformance.rs`, `docs/TESTING_STANDARDS.md` |"
    }
  ],

  "policies": [
    {
      "policy_id": "require-read-before-modify",
      "type": "requires_approval",
      "actions": ["code.modify"],
      "reason": "You MUST read any file before modifying it. Check the 'Files You MUST Read First' section in the injected context."
    }
  ],

  "actions": [
    {
      "action_id": "code.read",
      "name": "Read Code",
      "description": "Read source code files",
      "parameters_schema": {"type": "object"},
      "risk_tier": "low"
    },
    {
      "action_id": "code.modify",
      "name": "Modify Code",
      "description": "Edit source code files",
      "parameters_schema": {"type": "object"},
      "risk_tier": "medium"
    },
    {
      "action_id": "test.run",
      "name": "Run Tests",
      "description": "Execute test suite",
      "parameters_schema": {"type": "object"},
      "risk_tier": "low"
    },
    {
      "action_id": "docs.read",
      "name": "Read Documentation",
      "description": "Read documentation files",
      "parameters_schema": {"type": "object"},
      "risk_tier": "low"
    }
  ]
}
